# 数据库开发规范文档

# 一、目标

统一数据库设计和操作规范，提高数据库性能和可维护性，确保数据安全和一致性。

# 二、数据库规约

## 2.1 命名规约

1. 【强制】Prisma 模型命名使用 PascalCase 单数形式，数据库表名使用复数形式

```
// 正确示例 - schema.prisma
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  userName  String   @map("user_name")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  posts     Post[]
  profile   Profile?
  
  @@map("users")
  @@index([email])
}

model Post {
  id        String   @id @default(uuid())
  title     String
  content   String?
  published Boolean  @default(false)
  authorId  String   @map("author_id")
  
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  tags      Tag[]
  
  @@map("posts")
  @@index([authorId])
  @@index([published])
}

model Profile {
  id        String   @id @default(uuid())
  bio       String?
  avatar    String?
  userId    String   @unique @map("user_id")
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("profiles")
}

// 错误示例
model users {  // 错误：模型名应使用单数PascalCase
  id String @id
}

model User {
  id String @id
  @@map("user")  // 错误：表名应使用复数
}
```

1. 【强制】字段命名使用 camelCase，数据库列名使用 snake_case

```
// 正确示例
model Order {
  id            String   @id @default(uuid())
  orderNumber   String   @unique @map("order_number")
  totalAmount   Decimal  @map("total_amount") @db.Decimal(10, 2)
  shippingFee   Decimal  @default(0) @map("shipping_fee") @db.Decimal(10, 2)
  orderStatus   String   @default("pending") @map("order_status")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")
  
  @@map("orders")
  @@index([orderNumber])
  @@index([orderStatus])
}

// 错误示例
model Order {
  id String @id
  order_number String  // 错误：Prisma字段应使用camelCase
  OrderStatus String   // 错误：应使用camelCase
}
```

1. 【推荐】关联字段使用有意义的名称

```
// 正确示例
model Order {
  id        String @id @default(uuid())
  userId    String @map("user_id")
  
  user      User   @relation(fields: [userId], references: [id])
  items     OrderItem[]
  
  @@map("orders")
}

model OrderItem {
  id        String  @id @default(uuid())
  orderId   String  @map("order_id")
  productId String  @map("product_id")
  quantity  Int
  
  order     Order   @relation(fields: [orderId], references: [id])
  product   Product @relation(fields: [productId], references: [id])
  
  @@map("order_items")
}

// 不推荐
model Order {
  id   String @id
  uid  String @map("uid")  // 不够清晰，应使用userId
  
  u    User   @relation(fields: [uid], references: [id])  // 应使用user
}
```

## 2.2 字段设计

1. 【强制】主键使用 UUID，避免使用自增 ID

```
// 正确示例
model User {
  id String @id @default(uuid())  // 使用UUID
  // 或使用cuid
  // id String @id @default(cuid())
  
  @@map("users")
}

// 不推荐（仅特殊场景使用）
model User {
  id Int @id @default(autoincrement())  // 自增ID可能暴露数据量
  
  @@map("users")
}
```

1. 【强制】所有表必须包含 createdAt 和 updatedAt 字段

```
// 正确示例
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  @@map("users")
}

model Post {
  id        String   @id @default(uuid())
  title     String
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  publishedAt DateTime? @map("published_at")  // 可选的发布时间
  
  @@map("posts")
}
```

1. 【推荐】使用枚举类型定义固定值字段

```
// 正确示例
enum UserRole {
  ADMIN
  USER
  GUEST
}

enum UserStatus {
  ACTIVE
  INACTIVE
  BANNED
}

enum OrderStatus {
  PENDING
  PROCESSING
  COMPLETED
  CANCELLED
  REFUNDED
}

model User {
  id        String     @id @default(uuid())
  email     String     @unique
  role      UserRole   @default(USER)
  status    UserStatus @default(ACTIVE)
  
  @@map("users")
}

model Order {
  id        String      @id @default(uuid())
  status    OrderStatus @default(PENDING)
  
  @@map("orders")
}

// 不推荐
model User {
  id     String @id @default(uuid())
  role   String @default("user")  // 应使用枚举
  status String @default("active")  // 应使用枚举
  
  @@map("users")
}
```

1. 【强制】金额字段使用 Decimal 类型

```
// 正确示例
model Product {
  id       String  @id @default(uuid())
  name     String
  price    Decimal @db.Decimal(10, 2)  // 10位数字，2位小数
  cost     Decimal @default(0) @db.Decimal(10, 2)
  
  @@map("products")
}

model Order {
  id            String  @id @default(uuid())
  subtotal      Decimal @db.Decimal(10, 2)
  discount      Decimal @default(0) @db.Decimal(10, 2)
  shippingFee   Decimal @default(0) @db.Decimal(10, 2)
  totalAmount   Decimal @db.Decimal(10, 2)
  
  @@map("orders")
}

// 错误示例
model Product {
  id    String @id @default(uuid())
  price Float  // 错误：金额不应使用Float，会有精度问题
  
  @@map("products")
}
```

1. 【推荐】Boolean 字段使用 is、has 等前缀

```
// 正确示例
model User {
  id            String  @id @default(uuid())
  isEmailVerified Boolean @default(false) @map("is_email_verified")
  isDeleted     Boolean @default(false) @map("is_deleted")
  hasAvatar     Boolean @default(false) @map("has_avatar")
  
  @@map("users")
}

model Post {
  id          String  @id @default(uuid())
  isPublished Boolean @default(false) @map("is_published")
  isFeatured  Boolean @default(false) @map("is_featured")
  
  @@map("posts")
}
```

1. 【推荐】使用软删除而非物理删除

```
// 正确示例
model User {
  id        String    @id @default(uuid())
  email     String    @unique
  isDeleted Boolean   @default(false) @map("is_deleted")
  deletedAt DateTime? @map("deleted_at")
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  
  @@map("users")
  @@index([isDeleted])
}

// 查询时过滤已删除数据
async findActiveUsers() {
  return await prisma.user.findMany({
    where: {
      isDeleted: false
    }
  })
}

// 软删除实现
async softDelete(id: string) {
  return await prisma.user.update({
    where: { id },
    data: {
      isDeleted: true,
      deletedAt: new Date()
    }
  })
}
```

## 2.3 索引设计

1. 【强制】为常用查询字段添加索引

```
// 正确示例
model User {
  id        String   @id @default(uuid())
  email     String   @unique  // 自动创建唯一索引
  userName  String   @map("user_name")
  phone     String?  @unique  // 可选但唯一
  status    String
  createdAt DateTime @default(now()) @map("created_at")
  
  @@map("users")
  @@index([userName])  // 经常用于搜索
  @@index([status])    // 经常用于筛选
  @@index([createdAt]) // 经常用于排序
}

model Post {
  id          String   @id @default(uuid())
  title       String
  authorId    String   @map("author_id")
  categoryId  String   @map("category_id")
  isPublished Boolean  @default(false) @map("is_published")
  publishedAt DateTime? @map("published_at")
  views       Int      @default(0)
  
  author      User     @relation(fields: [authorId], references: [id])
  
  @@map("posts")
  @@index([authorId])      // 外键索引
  @@index([categoryId])    // 外键索引
  @@index([isPublished])   // 状态筛选
  @@index([publishedAt])   // 时间排序
  @@index([views])         // 热门排序
}
```

1. 【推荐】创建复合索引优化多条件查询

```
// 正确示例
model Order {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  status    String
  createdAt DateTime @default(now()) @map("created_at")
  
  @@map("orders")
  @@index([userId, status])        // 复合索引：按用户查询特定状态订单
  @@index([status, createdAt])     // 复合索引：按状态和时间查询
  @@index([userId, createdAt])     // 复合索引：按用户和时间查询
}

// 查询示例（会使用索引）
await prisma.order.findMany({
  where: {
    userId: 'user-id',
    status: 'completed'
  },
  orderBy: {
    createdAt: 'desc'
  }
})
```

1. 【推荐】避免过多索引，权衡查询和写入性能

```
// 正确示例 - 合理的索引数量
model Product {
  id          String   @id @default(uuid())
  name        String
  categoryId  String   @map("category_id")
  price       Decimal  @db.Decimal(10, 2)
  stock       Int
  isAvailable Boolean  @default(true) @map("is_available")
  createdAt   DateTime @default(now()) @map("created_at")
  
  @@map("products")
  @@index([categoryId])              // 分类查询
  @@index([isAvailable, price])      // 可售商品按价格排序
  @@index([name])                    // 名称搜索
  // 不要为每个字段都创建索引
}

// 不推荐 - 索引过多
model Product {
  id          String   @id @default(uuid())
  name        String
  categoryId  String   @map("category_id")
  price       Decimal  @db.Decimal(10, 2)
  stock       Int
  
  @@map("products")
  @@index([name])
  @@index([categoryId])
  @@index([price])
  @@index([stock])
  @@index([name, categoryId])
  @@index([categoryId, price])
  @@index([price, stock])
  // 索引过多会影响写入性能
}
```

## 2.4 关系设计

1. 【强制】使用外键约束保证数据完整性

```
// 正确示例 - 一对多关系
model User {
  id    String @id @default(uuid())
  email String @unique
  
  posts Post[]
  
  @@map("users")
}

model Post {
  id       String @id @default(uuid())
  title    String
  authorId String @map("author_id")
  
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  @@map("posts")
  @@index([authorId])
}

// 正确示例 - 一对一关系
model User {
  id      String   @id @default(uuid())
  email   String   @unique
  
  profile Profile?
  
  @@map("users")
}

model Profile {
  id     String @id @default(uuid())
  bio    String?
  userId String @unique @map("user_id")
  
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("profiles")
}

// 正确示例 - 多对多关系
model Post {
  id    String @id @default(uuid())
  title String
  
  tags  PostTag[]
  
  @@map("posts")
}

model Tag {
  id    String @id @default(uuid())
  name  String @unique
  
  posts PostTag[]
  
  @@map("tags")
}

model PostTag {
  postId String @map("post_id")
  tagId  String @map("tag_id")
  
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag    Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  @@id([postId, tagId])
  @@map("post_tags")
}
```

1. 【推荐】合理使用级联删除和限制删除

```
// 正确示例
model User {
  id       String    @id @default(uuid())
  email    String    @unique
  
  posts    Post[]
  orders   Order[]
  comments Comment[]
  
  @@map("users")
}

// 文章被删除时，评论也被删除（级联删除）
model Post {
  id       String    @id @default(uuid())
  title    String
  authorId String    @map("author_id")
  
  author   User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  comments Comment[]
  
  @@map("posts")
}

model Comment {
  id       String @id @default(uuid())
  content  String
  postId   String @map("post_id")
  userId   String @map("user_id")
  
  post     Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("comments")
}

// 订单不应被级联删除（限制删除或软删除）
model Order {
  id        String  @id @default(uuid())
  userId    String  @map("user_id")
  isDeleted Boolean @default(false) @map("is_deleted")
  
  user      User    @relation(fields: [userId], references: [id], onDelete: Restrict)
  
  @@map("orders")
}
```

## 2.5 查询优化

1. 【强制】避免 N+1 查询问题，使用 include 或 select

```typescript
// 正确示例 - 使用include
const postsWithAuthor = await prisma.post.findMany({
  include: {
    author: {
      select: {
        id: true,
        userName: true,
        email: true
      }
    },
    comments: {
      take: 5,
      orderBy: {
        createdAt: 'desc'
      }
    }
  }
})

// 正确示例 - 使用select只查询需要的字段
const users = await prisma.user.findMany({
  select: {
    id: true,
    email: true,
    userName: true,
    posts: {
      select: {
        id: true,
        title: true
      }
    }
  }
})

// 错误示例 - N+1查询
const posts = await prisma.post.findMany()
for (const post of posts) {
  const author = await prisma.user.findUnique({  // 每次循环都查询数据库
    where: { id: post.authorId }
  })
  post.author = author
}
```

1. 【推荐】使用分页查询处理大量数据

```typescript
// 正确示例 - 基于偏移量的分页
async function getPaginatedUsers(page: number, pageSize: number) {
  const skip = (page - 1) * pageSize
  
  const [users, total] = await Promise.all([
    prisma.user.findMany({
      skip,
      take: pageSize,
      orderBy: {
        createdAt: 'desc'
      }
    }),
    prisma.user.count()
  ])
  
  return {
    data: users,
    pagination: {
      page,
      pageSize,
      total,
      totalPages: Math.ceil(total / pageSize)
    }
  }
}

// 更优 - 基于游标的分页（适合大数据集）
async function getCursorPaginatedUsers(cursor?: string, take: number = 20) {
  const users = await prisma.user.findMany({
    take: take + 1,
    ...(cursor && {
      cursor: { id: cursor },
      skip: 1
    }),
    orderBy: {
      createdAt: 'desc'
    }
  })
  
  const hasMore = users.length > take
  const data = hasMore ? users.slice(0, -1) : users
  const nextCursor = hasMore ? data[data.length - 1].id : undefined
  
  return {
    data,
    nextCursor,
    hasMore
  }
}
```

1. 【推荐】使用聚合函数进行统计查询

```typescript
// 正确示例
async function getUserStatistics(userId: string) {
  const stats = await prisma.post.aggregate({
    where: {
      authorId: userId,
      isPublished: true
    },
    _count: {
      id: true
    },
    _sum: {
      views: true
    },
    _avg: {
      views: true
    },
    _max: {
      views: true
    }
  })
  
  return {
    totalPosts: stats._count.id,
    totalViews: stats._sum.views,
    averageViews: stats._avg.views,
    maxViews: stats._max.views
  }
}

// 使用groupBy进行分组统计
async function getPostsByCategory() {
  return await prisma.post.groupBy({
    by: ['categoryId'],
    _count: {
      id: true
    },
    _sum: {
      views: true
    },
    where: {
      isPublished: true
    }
  })
}
```

1. 【强制】使用事务保证数据一致性

```typescript
// 正确示例 - 交互式事务
async function transferMoney(fromUserId: string, toUserId: string, amount: number) {
  return await prisma.$transaction(async (tx) => {
    // 检查余额
    const fromAccount = await tx.account.findUnique({
      where: { userId: fromUserId }
    })
    
    if (!fromAccount || fromAccount.balance < amount) {
      throw new Error('余额不足')
    }
    
    // 扣减发送方余额
    await tx.account.update({
      where: { userId: fromUserId },
      data: {
        balance: {
          decrement: amount
        }
      }
    })
    
    // 增加接收方余额
    await tx.account.update({
      where: { userId: toUserId },
      data: {
        balance: {
          increment: amount
        }
      }
    })
    
    // 创建交易记录
    const transaction = await tx.transaction.create({
      data: {
        fromUserId,
        toUserId,
        amount,
        type: 'transfer',
        status: 'completed'
      }
    })
    
    return transaction
  })
}

// 正确示例 - 批量操作事务
async function batchUpdateUserStatus(userIds: string[], status: UserStatus) {
  return await prisma.$transaction(
    userIds.map(id =>
      prisma.user.update({
        where: { id },
        data: { status }
      })
    )
  )
}
```

## 2.6 数据库安全

1. 【强制】敏感数据加密存储

```
// 正确示例
model User {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String   @map("password_hash")  // 存储加密后的密码
  phone        String?  // 可考虑加密
  idCard       String?  @map("id_card")        // 身份证号应加密
  
  @@map("users")
}

// 应用层加密
import * as bcrypt from 'bcrypt'

async function createUser(email: string, password: string) {
  const passwordHash = await bcrypt.hash(password, 10)
  
  return await prisma.user.create({
    data: {
      email,
      passwordHash
    }
  })
}

async function verifyPassword(user: User, password: string): Promise<boolean> {
  return await bcrypt.compare(password, user.passwordHash)
}
```

1. 【强制】使用环境变量管理数据库连接

```bash
# .env
DATABASE_URL="postgresql://username:password@localhost:5432/mydb?schema=public"

# .env.production
DATABASE_URL="postgresql://username:password@prod-server:5432/mydb?schema=public&connection_limit=10&pool_timeout=20"
```

1. 【推荐】限制数据库用户权限

```sql
-- 创建只读用户（用于报表查询等）
CREATE USER readonly_user WITH PASSWORD 'password';
GRANT CONNECT ON DATABASE mydb TO readonly_user;
GRANT USAGE ON SCHEMA public TO readonly_user;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO readonly_user;

-- 创建应用用户（限制权限）
CREATE USER app_user WITH PASSWORD 'password';
GRANT CONNECT ON DATABASE mydb TO app_user;
GRANT USAGE ON SCHEMA public TO app_user;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO app_user;
GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO app_user;
```

## 2.7 性能优化

1. 【推荐】配置数据库连接池

```typescript
// prisma/schema.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// .env中配置连接池参数
// DATABASE_URL="postgresql://user:password@localhost:5432/mydb?schema=public&connection_limit=20&pool_timeout=30&connect_timeout=10"

// 在生产环境使用连接池配置
// connection_limit: 最大连接数 (默认: 无限制)
// pool_timeout: 获取连接的超时时间(秒) (默认: 10)
// connect_timeout: 建立连接的超时时间(秒) (默认: 5)
```

1. 【推荐】使用 Redis 缓存热点数据

```typescript
// 正确示例 - 缓存查询结果
@Injectable()
export class UserService {
  constructor(
    private prisma: PrismaService,
    private redis: RedisService
  ) {}
  
  async findById(id: string): Promise<User | null> {
    const cacheKey = REDIS_KEYS.USER_CACHE(id)
    
    // 先从缓存获取
    const cached = await this.redis.get(cacheKey)
    if (cached) {
      return JSON.parse(cached)
    }
    
    // 从数据库查询
    const user = await this.prisma.user.findUnique({
      where: { id }
    })
    
    // 缓存结果
    if (user) {
      await this.redis.set(
        cacheKey,
        JSON.stringify(user),
        'EX',
        REDIS_TTL.USER_CACHE
      )
    }
    
    return user
  }
  
  async update(id: string, data: UpdateUserDto): Promise<User> {
    const user = await this.prisma.user.update({
      where: { id },
      data
    })
    
    // 更新后清除缓存
    const cacheKey = REDIS_KEYS.USER_CACHE(id)
    await this.redis.del(cacheKey)
    
    return user
  }
}
```

1. 【推荐】定期清理历史数据

```typescript
// 正确示例 - 定时任务清理过期数据
@Injectable()
export class CleanupService {
  private readonly logger = new Logger(CleanupService.name)
  
  constructor(private prisma: PrismaService) {}
  
  @Cron('0 2 * * *')  // 每天凌晨2点执行
  async cleanupOldData() {
    this.logger.log('开始清理过期数据')
    
    const thirtyDaysAgo = new Date()
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)
    
    try {
      // 清理过期的会话
      const deletedSessions = await this.prisma.session.deleteMany({
        where: {
          expiresAt: {
            lt: new Date()
          }
        }
      })
      
      this.logger.log(`清理了 ${deletedSessions.count} 个过期会话`)
      
      // 归档旧订单
      const oldOrders = await this.prisma.order.findMany({
        where: {
          status: 'completed',
          updatedAt: {
            lt: thirtyDaysAgo
          }
        }
      })
      
      // 将旧订单移到归档表
      await this.prisma.archivedOrder.createMany({
        data: oldOrders
      })
      
      // 删除已归档的订单
      await this.prisma.order.deleteMany({
        where: {
          id: {
            in: oldOrders.map(o => o.id)
          }
        }
      })
      
      this.logger.log(`归档了 ${oldOrders.length} 个订单`)
    } catch (error) {
      this.logger.error('清理数据失败', error)
    }
  }
}
```

## 2.8 数据备份

1. 【强制】定期备份数据库

```bash
#!/bin/bash
# backup.sh - PostgreSQL备份脚本

BACKUP_DIR="/var/backups/postgresql"
DATE=$(date +%Y%m%d_%H%M%S)
DATABASE="mydb"

# 创建备份目录
mkdir -p $BACKUP_DIR

# 执行备份
pg_dump -U postgres $DATABASE | gzip > $BACKUP_DIR/${DATABASE}_${DATE}.sql.gz

# 删除30天前的备份
find $BACKUP_DIR -name "*.sql.gz" -mtime +30 -delete

echo "备份完成: ${DATABASE}_${DATE}.sql.gz"

# 添加到crontab
# 0 3 * * * /path/to/backup.sh
```

1. 【推荐】使用 Prisma Migrate 管理数据库版本

```bash
# 创建迁移
npx prisma migrate dev --name add_user_profile

# 应用迁移到生产环境
npx prisma migrate deploy

# 重置开发数据库
npx prisma migrate reset

# 查看迁移状态
npx prisma migrate status
```

# 三、参考资料

- [Prisma 官方文档](https://www.prisma.io/docs/)
- [PostgreSQL 性能优化](https://www.postgresql.org/docs/current/performance-tips.html)
- [PostgreSQL 索引最佳实践](https://www.postgresql.org/docs/current/indexes.html)
- [数据库设计规范](https://www.dbdesigner.net/designer)
- [Redis 最佳实践](https://redis.io/docs/manual/patterns/)
- [阿里巴巴 MySQL 开发规范](https://github.com/alibaba/p3c)
