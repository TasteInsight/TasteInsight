# 后端开发规范文档

# 一、目标

统一代码风格、命名规范，增强代码可读性和可维护性，供日常开发工作中参考，以提高团队协作的开发效率。

# 二、编程规约

## 2.1 命名规约

1. 【强制】模块、控制器、服务文件命名使用小写字母，多个单词用中划线分隔

```
// 正确示例 - Nest.js项目结构
src/
  modules/
    user/
      - user.module.ts
      - user.controller.ts
      - user.service.ts
      - dto/
        - create-user.dto.ts
        - update-user.dto.ts
      - entities/
        - user.entity.ts
    order/
      - order.module.ts
      - order.controller.ts
      - order.service.ts

// 错误示例
src/
  modules/
    User/              // 错误：应使用小写
      - UserController.ts  // 错误：文件名应用小写
      - user_service.ts    // 错误：应使用中划线
```

1. 【强制】类名使用 PascalCase（大驼峰），并遵循 Nest.js 命名约定

```typescript
// 正确示例
@Controller('users')
export class UserController {
  constructor(private readonly userService: UserService) {}
}

@Injectable()
export class UserService {
  constructor(
    private prisma: PrismaService,
    private redis: RedisService
  ) {}
}

@Module({
  imports: [PrismaModule],
  controllers: [UserController],
  providers: [UserService],
  exports: [UserService]
})
export class UserModule {}

// 错误示例
@Controller('users')
export class userController {  // 错误：应使用PascalCase
  // ...
}

export class User_Service {  // 错误：不应使用下划线
  // ...
}
```

1. 【强制】DTO 和 Entity 类命名遵循约定

```typescript
// 正确示例 - DTO命名
export class CreateUserDto {
  @IsEmail()
  @IsNotEmpty()
  email: string
  
  @IsString()
  @MinLength(3)
  @MaxLength(20)
  userName: string
  
  @IsString()
  @MinLength(6)
  password: string
}

export class UpdateUserDto extends PartialType(CreateUserDto) {}

export class UserResponseDto {
  id: string
  email: string
  userName: string
  createdAt: Date
}

// 正确示例 - Entity命名
export class User {
  id: string
  email: string
  userName: string
  passwordHash: string
  createdAt: Date
  updatedAt: Date
}

// 错误示例
export class userDto {  // 错误：应使用PascalCase
  email: string
}

export class User_Entity {  // 错误：不应使用下划线
  id: string
}
```

1. 【强制】接口命名使用 PascalCase，并以 I 开头

```typescript
// 正确示例
export interface IUserService {
  findById(id: string): Promise<User | null>
  create(createUserDto: CreateUserDto): Promise<User>
  update(id: string, updateUserDto: UpdateUserDto): Promise<User>
  delete(id: string): Promise<void>
}

export interface IAuthPayload {
  userId: string
  email: string
  role: string
}

export interface IPaginationOptions {
  page: number
  limit: number
  orderBy?: string
  order?: 'asc' | 'desc'
}

// 错误示例
export interface UserService {  // 错误：应以I开头
  findById(id: string): Promise<User | null>
}

export interface i_auth_payload {  // 错误：应使用PascalCase
  userId: string
}
```

1. 【强制】变量、函数命名使用 camelCase，常量使用 UPPER_SNAKE_CASE

```typescript
// 正确示例
const userId = '123'
const userEmail = 'user@example.com'
const MAX_RETRY_COUNT = 3
const JWT_SECRET = process.env.JWT_SECRET
const TOKEN_EXPIRATION = '7d'

async function findUserById(id: string): Promise<User | null> {
  return await this.prisma.user.findUnique({
    where: { id }
  })
}

async function sendWelcomeEmail(user: User): Promise<void> {
  // 发送欢迎邮件逻辑
}

// 错误示例
const user_id = '123'  // 错误：应使用camelCase
const UserEmail = 'user@example.com'  // 错误：应使用camelCase
const maxRetryCount = 3  // 错误：常量应使用UPPER_SNAKE_CASE

async function FindUserById(id: string) {  // 错误：应使用camelCase
  // ...
}
```

1. 【强制】环境变量命名使用 UPPER_SNAKE_CASE

```bash
# 正确示例 - .env
DATABASE_URL="postgresql://user:password@localhost:5432/mydb"
REDIS_HOST=localhost
REDIS_PORT=6379
JWT_SECRET=your-secret-key
JWT_EXPIRES_IN=7d
NODE_ENV=development
PORT=3000

# 错误示例
databaseUrl="postgresql://..."  # 错误：应使用UPPER_SNAKE_CASE
redis-host=localhost  # 错误：应使用下划线
jwtSecret=secret  # 错误：应使用UPPER_SNAKE_CASE
```

## 2.2 常量定义

1. 【强制】常量统一在 constants 文件中定义，按模块分类

```typescript
// 正确示例 - src/constants/auth.ts
export const AUTH_CONSTANTS = {
  JWT_SECRET: process.env.JWT_SECRET || 'default-secret',
  JWT_EXPIRES_IN: process.env.JWT_EXPIRES_IN || '7d',
  REFRESH_TOKEN_EXPIRES_IN: '30d',
  SALT_ROUNDS: 10
} as const

// src/constants/redis.ts
export const REDIS_KEYS = {
  USER_SESSION: (userId: string) => `user:session:${userId}`,
  USER_CACHE: (userId: string) => `user:cache:${userId}`,
  ORDER_LOCK: (orderId: string) => `order:lock:${orderId}`,
  RATE_LIMIT: (ip: string) => `rate:limit:${ip}`
} as const

export const REDIS_TTL = {
  USER_SESSION: 7 * 24 * 60 * 60,  // 7天
  USER_CACHE: 30 * 60,  // 30分钟
  ORDER_LOCK: 10,  // 10秒
  RATE_LIMIT: 60  // 1分钟
} as const

// src/constants/error-codes.ts
export const ERROR_CODES = {
  USER_NOT_FOUND: 'USER_NOT_FOUND',
  EMAIL_ALREADY_EXISTS: 'EMAIL_ALREADY_EXISTS',
  INVALID_CREDENTIALS: 'INVALID_CREDENTIALS',
  UNAUTHORIZED: 'UNAUTHORIZED',
  FORBIDDEN: 'FORBIDDEN',
  INSUFFICIENT_BALANCE: 'INSUFFICIENT_BALANCE'
} as const

export type ErrorCode = typeof ERROR_CODES[keyof typeof ERROR_CODES]

// 使用示例
import { AUTH_CONSTANTS, REDIS_KEYS, ERROR_CODES } from '@/constants'

const token = jwt.sign(payload, AUTH_CONSTANTS.JWT_SECRET)
await redis.set(REDIS_KEYS.USER_SESSION(userId), data)
throw new BusinessException(ERROR_CODES.USER_NOT_FOUND, '用户不存在')
```

1. 【推荐】使用枚举定义一组相关的常量

```typescript
// 正确示例
export enum UserRole {
  ADMIN = 'admin',
  USER = 'user',
  GUEST = 'guest'
}

export enum UserStatus {
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  BANNED = 'banned'
}

export enum OrderStatus {
  PENDING = 'pending',
  PROCESSING = 'processing',
  COMPLETED = 'completed',
  CANCELLED = 'cancelled',
  REFUNDED = 'refunded'
}

export enum PaymentMethod {
  WECHAT = 'wechat',
  ALIPAY = 'alipay',
  CREDIT_CARD = 'credit_card'
}

// 使用示例
@Post('register')
async register(@Body() createUserDto: CreateUserDto) {
  const user = await this.userService.create({
    ...createUserDto,
    role: UserRole.USER,
    status: UserStatus.ACTIVE
  })
  return user
}
```

1. 【强制】配置使用 ConfigModule 统一管理

```typescript
// 正确示例 - src/config/configuration.ts
export default () => ({
  port: parseInt(process.env.PORT, 10) || 3000,
  database: {
    url: process.env.DATABASE_URL
  },
  redis: {
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT, 10) || 6379,
    password: process.env.REDIS_PASSWORD || ''
  },
  jwt: {
    secret: process.env.JWT_SECRET,
    expiresIn: process.env.JWT_EXPIRES_IN || '7d'
  },
  email: {
    host: process.env.EMAIL_HOST,
    port: parseInt(process.env.EMAIL_PORT, 10),
    user: process.env.EMAIL_USER,
    password: process.env.EMAIL_PASSWORD
  }
})

// app.module.ts
import { Module } from '@nestjs/common'
import { ConfigModule } from '@nestjs/config'
import configuration from './config/configuration'

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      load: [configuration]
    })
  ]
})
export class AppModule {}

// 使用示例
@Injectable()
export class AuthService {
  constructor(
    private configService: ConfigService,
    private jwtService: JwtService
  ) {}
  
  async generateToken(payload: IAuthPayload): Promise<string> {
    const secret = this.configService.get<string>('jwt.secret')
    const expiresIn = this.configService.get<string>('jwt.expiresIn')
    
    return this.jwtService.sign(payload, {
      secret,
      expiresIn
    })
  }
}
```

## 2.3 控制语句

1. 【强制】使用===和!==进行比较，避免使用==和!=

```typescript
// 正确示例
if (user === null) {
  throw new NotFoundException('用户不存在')
}

if (status !== 'active') {
  throw new BadRequestException('用户状态异常')
}

if (count === 0) {
  return []
}

// 错误示例
if (user == null) {  // 错误：应使用===
  throw new NotFoundException('用户不存在')
}

if (status != 'active') {  // 错误：应使用!==
  throw new BadRequestException('用户状态异常')
}
```

1. 【强制】复杂的条件判断应提取为函数

```typescript
// 正确示例
private canUserEditPost(user: User, post: Post): boolean {
  return (
    user.role === UserRole.ADMIN ||
    (user.id === post.authorId && post.status === 'draft')
  )
}

@Put(':id')
async updatePost(
  @Param('id') id: string,
  @Body() updatePostDto: UpdatePostDto,
  @CurrentUser() user: User
) {
  const post = await this.postService.findById(id)
  
  if (!post) {
    throw new NotFoundException('文章不存在')
  }
  
  if (!this.canUserEditPost(user, post)) {
    throw new ForbiddenException('没有权限编辑此文章')
  }
  
  return await this.postService.update(id, updatePostDto)
}

// 不推荐
if (user.role === UserRole.ADMIN || (user.id === post.authorId && post.status === 'draft')) {
  // 条件过于复杂
}
```

1. 【推荐】使用可选链(?.)和空值合并运算符(??)简化代码

```typescript
// 正确示例
const userName = user?.profile?.name ?? 'Guest'
const userAge = user?.profile?.age ?? 0

async findUserPosts(userId: string) {
  const user = await this.prisma.user.findUnique({
    where: { id: userId },
    include: { posts: true }
  })
  
  return user?.posts ?? []
}

// 不推荐
const userName = user && user.profile && user.profile.name 
  ? user.profile.name 
  : 'Guest'
```

1. 【推荐】使用早返回(early return)减少嵌套层级

```typescript
// 正确示例
async updateUser(id: string, updateUserDto: UpdateUserDto): Promise<User> {
  if (!id) {
    throw new BadRequestException('用户ID不能为空')
  }
  
  const user = await this.prisma.user.findUnique({
    where: { id }
  })
  
  if (!user) {
    throw new NotFoundException('用户不存在')
  }
  
  if (user.status === UserStatus.BANNED) {
    throw new ForbiddenException('用户已被封禁')
  }
  
  return await this.prisma.user.update({
    where: { id },
    data: updateUserDto
  })
}

// 不推荐
async updateUser(id: string, updateUserDto: UpdateUserDto): Promise<User> {
  if (id) {
    const user = await this.prisma.user.findUnique({ where: { id } })
    if (user) {
      if (user.status !== UserStatus.BANNED) {
        return await this.prisma.user.update({
          where: { id },
          data: updateUserDto
        })
      }
    }
  }
  throw new BadRequestException('操作失败')
}
```

## 2.4 集合处理

1. 【推荐】优先使用数组的高阶函数(map、filter、reduce 等)

```typescript
// 正确示例
async getUsersWithPosts(): Promise<UserWithPostsDto[]> {
  const users = await this.prisma.user.findMany({
    include: { posts: true }
  })
  
  return users
    .filter(user => user.status === UserStatus.ACTIVE)
    .map(user => ({
      id: user.id,
      userName: user.userName,
      postsCount: user.posts.length,
      latestPost: user.posts[0]
    }))
}

// 统计数据
const totalAmount = orders.reduce((sum, order) => sum + order.amount, 0)
const averageAmount = totalAmount / orders.length

// 分组统计
const ordersByStatus = orders.reduce((acc, order) => {
  const status = order.status
  acc[status] = (acc[status] || 0) + 1
  return acc
}, {} as Record<string, number>)
```

1. 【强制】避免在循环中进行数据库查询，使用批量查询或 include

```typescript
// 正确示例 - 使用include
async getOrdersWithDetails(userId: string) {
  return await this.prisma.order.findMany({
    where: { userId },
    include: {
      items: {
        include: {
          product: true
        }
      },
      user: {
        select: {
          id: true,
          userName: true
        }
      }
    }
  })
}

// 正确示例 - 批量查询
async getUsersWithRoles(userIds: string[]) {
  const users = await this.prisma.user.findMany({
    where: {
      id: { in: userIds }
    }
  })
  
  const roles = await this.prisma.role.findMany({
    where: {
      userId: { in: userIds }
    }
  })
  
  return users.map(user => ({
    ...user,
    roles: roles.filter(role => role.userId === user.id)
  }))
}

// 错误示例 - N+1查询问题
async getOrdersWithDetails(userId: string) {
  const orders = await this.prisma.order.findMany({
    where: { userId }
  })
  
  for (const order of orders) {
    order.items = await this.prisma.orderItem.findMany({  // 错误：循环中查询
      where: { orderId: order.id }
    })
  }
  
  return orders
}
```

1. 【推荐】使用 Set 和 Map 优化查找和去重

```typescript
// 正确示例 - 使用Set去重
async getUniqueCategories(posts: Post[]): Promise<string[]> {
  const categories = posts
    .flatMap(post => post.categories)
    .filter(Boolean)
  
  return [...new Set(categories)]
}

// 正确示例 - 使用Map优化查找
async enrichOrdersWithUserInfo(orders: Order[]) {
  const userIds = [...new Set(orders.map(order => order.userId))]
  const users = await this.prisma.user.findMany({
    where: { id: { in: userIds } }
  })
  
  const userMap = new Map(users.map(user => [user.id, user]))
  
  return orders.map(order => ({
    ...order,
    user: userMap.get(order.userId)
  }))
}
```

## 2.5 线程安全

1. 【强制】使用 Redis 分布式锁避免并发问题

```typescript
// 正确示例 - Redis分布式锁
@Injectable()
export class OrderService {
  constructor(
    private prisma: PrismaService,
    private redis: RedisService
  ) {}
  
  async createOrder(userId: string, createOrderDto: CreateOrderDto): Promise<Order> {
    const lockKey = REDIS_KEYS.ORDER_LOCK(`${userId}:${createOrderDto.productId}`)
    const lockValue = Date.now().toString()
    const lockExpire = REDIS_TTL.ORDER_LOCK
    
    // 获取分布式锁
    const acquired = await this.redis.set(
      lockKey,
      lockValue,
      'NX',
      'EX',
      lockExpire
    )
    
    if (!acquired) {
      throw new ConflictException('操作频繁，请稍后重试')
    }
    
    try {
      // 检查库存
      const product = await this.prisma.product.findUnique({
        where: { id: createOrderDto.productId }
      })
      
      if (!product || product.stock < createOrderDto.quantity) {
        throw new BadRequestException('库存不足')
      }
      
      // 创建订单并减少库存
      return await this.prisma.$transaction(async (tx) => {
        const order = await tx.order.create({
          data: {
            userId,
            productId: createOrderDto.productId,
            quantity: createOrderDto.quantity,
            amount: product.price * createOrderDto.quantity
          }
        })
        
        await tx.product.update({
          where: { id: createOrderDto.productId },
          data: {
            stock: { decrement: createOrderDto.quantity }
          }
        })
        
        return order
      })
    } finally {
      // 释放锁
      const currentValue = await this.redis.get(lockKey)
      if (currentValue === lockValue) {
        await this.redis.del(lockKey)
      }
    }
  }
}
```

1. 【强制】使用事务处理确保数据一致性

```typescript
// 正确示例 - Prisma事务
async transferMoney(
  fromUserId: string,
  toUserId: string,
  amount: number
): Promise<void> {
  await this.prisma.$transaction(async (tx) => {
    // 检查发送方余额
    const fromAccount = await tx.account.findUnique({
      where: { userId: fromUserId }
    })
    
    if (!fromAccount || fromAccount.balance < amount) {
      throw new BadRequestException('余额不足')
    }
    
    // 扣减发送方余额
    await tx.account.update({
      where: { userId: fromUserId },
      data: { balance: { decrement: amount } }
    })
    
    // 增加接收方余额
    await tx.account.update({
      where: { userId: toUserId },
      data: { balance: { increment: amount } }
    })
    
    // 创建交易记录
    await tx.transaction.create({
      data: {
        fromUserId,
        toUserId,
        amount,
        type: 'transfer',
        status: 'completed'
      }
    })
  })
}
```

1. 【推荐】使用乐观锁处理并发更新

```typescript
// 正确示例 - 使用version字段实现乐观锁
async updatePost(
  id: string,
  updatePostDto: UpdatePostDto,
  version: number
): Promise<Post> {
  const result = await this.prisma.post.updateMany({
    where: {
      id,
      version
    },
    data: {
      ...updatePostDto,
      version: { increment: 1 }
    }
  })
  
  if (result.count === 0) {
    throw new ConflictException('数据已被其他用户修改，请刷新后重试')
  }
  
  return await this.prisma.post.findUnique({
    where: { id }
  })
}
```

1. 【强制】防止重复提交，验证幂等性

```typescript
// 正确示例 - 幂等性验证
@Post('orders')
async createOrder(
  @Body() createOrderDto: CreateOrderDto,
  @Headers('idempotency-key') idempotencyKey: string,
  @CurrentUser() user: User
) {
  if (!idempotencyKey) {
    throw new BadRequestException('缺少幂等性密钥')
  }
  
  const cacheKey = `idempotency:${idempotencyKey}`
  
  // 检查是否已处理
  const cached = await this.redis.get(cacheKey)
  if (cached) {
    return JSON.parse(cached)
  }
  
  // 处理业务逻辑
  const order = await this.orderService.create(user.id, createOrderDto)
  
  // 缓存结果（1小时）
  await this.redis.set(
    cacheKey,
    JSON.stringify(order),
    'EX',
    3600
  )
  
  return order
}
```

## 2.6 异步任务处理

1. 【推荐】使用 BullMQ 处理异步任务和队列

```typescript
// 正确示例 - 配置队列
// queue/email.processor.ts
import { Processor, Process } from '@nestjs/bull'
import { Job } from 'bull'
import { Logger } from '@nestjs/common'

interface IEmailJob {
  to: string
  subject: string
  content: string
  template?: string
}

@Processor('email')
export class EmailProcessor {
  private readonly logger = new Logger(EmailProcessor.name)
  
  @Process('send')
  async handleSendEmail(job: Job<IEmailJob>) {
    this.logger.log(`处理邮件任务: ${job.id}`)
    
    const { to, subject, content } = job.data
    
    try {
      await this.sendEmail(to, subject, content)
      this.logger.log(`邮件发送成功: ${to}`)
      return { success: true }
    } catch (error) {
      this.logger.error(`邮件发送失败: ${to}`, error)
      throw error
    }
  }
  
  @Process('sendBatch')
  async handleSendBatchEmail(job: Job<IEmailJob[]>) {
    this.logger.log(`处理批量邮件任务: ${job.id}`)
    
    const results = await Promise.allSettled(
      job.data.map(email => this.sendEmail(email.to, email.subject, email.content))
    )
    
    return {
      total: results.length,
      success: results.filter(r => r.status === 'fulfilled').length,
      failed: results.filter(r => r.status === 'rejected').length
    }
  }
  
  private async sendEmail(to: string, subject: string, content: string) {
    // 实际的邮件发送逻辑
    await new Promise(resolve => setTimeout(resolve, 1000))
  }
}

// 在服务中使用队列
import { InjectQueue } from '@nestjs/bull'
import { Queue } from 'bull'

@Injectable()
export class UserService {
  constructor(
    private prisma: PrismaService,
    @InjectQueue('email') private emailQueue: Queue
  ) {}
  
  async registerUser(createUserDto: CreateUserDto): Promise<User> {
    const user = await this.prisma.user.create({
      data: {
        ...createUserDto,
        role: UserRole.USER,
        status: UserStatus.ACTIVE
      }
    })
    
    // 添加到队列异步发送欢迎邮件
    await this.emailQueue.add('send', {
      to: user.email,
      subject: '欢迎注册',
      content: `欢迎 ${user.userName} 加入我们！`
    }, {
      attempts: 3,  // 失败重试3次
      backoff: {
        type: 'exponential',
        delay: 2000
      }
    })
    
    return user
  }
}

// queue.module.ts
import { Module } from '@nestjs/common'
import { BullModule } from '@nestjs/bull'
import { EmailProcessor } from './email.processor'

@Module({
  imports: [
    BullModule.registerQueue({
      name: 'email',
      redis: {
        host: process.env.REDIS_HOST,
        port: parseInt(process.env.REDIS_PORT)
      }
    })
  ],
  providers: [EmailProcessor],
  exports: [BullModule]
})
export class QueueModule {}
```

1. 【推荐】使用定时任务处理周期性工作

```typescript
// 正确示例 - Nest.js定时任务
import { Injectable, Logger } from '@nestjs/common'
import { Cron, CronExpression } from '@nestjs/schedule'

@Injectable()
export class TasksService {
  private readonly logger = new Logger(TasksService.name)
  
  constructor(private prisma: PrismaService) {}
  
  // 每天凌晨1点执行
  @Cron('0 1 * * *')
  async handleDailyCleanup() {
    this.logger.log('开始执行每日清理任务')
    
    try {
      // 清理过期的会话
      const deletedSessions = await this.prisma.session.deleteMany({
        where: {
          expiresAt: {
            lt: new Date()
          }
        }
      })
      
      this.logger.log(`清理了 ${deletedSessions.count} 个过期会话`)
      
      // 清理临时文件
      await this.cleanupTempFiles()
      
      this.logger.log('每日清理任务完成')
    } catch (error) {
      this.logger.error('每日清理任务失败', error)
    }
  }
  
  // 每小时执行一次
  @Cron(CronExpression.EVERY_HOUR)
  async handleHourlySync() {
    this.logger.log('开始同步数据')
    
    try {
      await this.syncData()
    } catch (error) {
      this.logger.error('数据同步失败', error)
    }
  }
  
  // 每5分钟执行一次
  @Cron('*/5 * * * *')
  async handleCacheRefresh() {
    this.logger.log('刷新缓存')
    
    try {
      await this.refreshCache()
    } catch (error) {
      this.logger.error('缓存刷新失败', error)
    }
  }
  
  private async cleanupTempFiles() {
    // 清理临时文件逻辑
  }
  
  private async syncData() {
    // 数据同步逻辑
  }
  
  private async refreshCache() {
    // 缓存刷新逻辑
  }
}
```

## 2.7 注释规范

1. 【强制】类、接口、重要函数必须添加 JSDoc 注释

```typescript
/**
 * 用户服务类
 * 负责处理用户相关的业务逻辑
 * 
 * @class UserService
 * @author zhangsan
 * @since 2025-10-01
 */
@Injectable()
export class UserService {
  constructor(
    private prisma: PrismaService,
    private redis: RedisService
  ) {}
  
  /**
   * 根据ID查找用户
   * @param id - 用户ID
   * @returns 用户信息，如果不存在则返回null
   * @throws {NotFoundException} 当用户不存在时抛出
   */
  async findById(id: string): Promise<User | null> {
    const cacheKey = REDIS_KEYS.USER_CACHE(id)
    
    // 先从缓存获取
    const cached = await this.redis.get(cacheKey)
    if (cached) {
      return JSON.parse(cached)
    }
    
    // 从数据库查询
    const user = await this.prisma.user.findUnique({
      where: { id }
    })
    
    if (user) {
      // 缓存结果
      await this.redis.set(
        cacheKey,
        JSON.stringify(user),
        'EX',
        REDIS_TTL.USER_CACHE
      )
    }
    
    return user
  }
  
  /**
   * 创建新用户
   * @param createUserDto - 创建用户的数据传输对象
   * @returns 创建成功的用户信息
   * @throws {ConflictException} 当邮箱已存在时抛出
   */
  async create(createUserDto: CreateUserDto): Promise<User> {
    // 检查邮箱是否已存在
    const existingUser = await this.prisma.user.findUnique({
      where: { email: createUserDto.email }
    })
    
    if (existingUser) {
      throw new ConflictException('邮箱已被使用')
    }
    
    // 加密密码
    const passwordHash = await bcrypt.hash(
      createUserDto.password,
      AUTH_CONSTANTS.SALT_ROUNDS
    )
    
    return await this.prisma.user.create({
      data: {
        ...createUserDto,
        passwordHash,
        role: UserRole.USER,
        status: UserStatus.ACTIVE
      }
    })
  }
}

/**
 * 用户控制器
 * 处理用户相关的HTTP请求
 * 
 * @class UserController
 */
@Controller('users')
@ApiTags('用户管理')
export class UserController {
  constructor(private readonly userService: UserService) {}
  
  /**
   * 获取用户列表
   * @param query - 分页和筛选参数
   * @returns 用户列表和分页信息
   */
  @Get()
  @ApiOperation({ summary: '获取用户列表' })
  @ApiResponse({ status: 200, description: '成功', type: [UserResponseDto] })
  async findAll(@Query() query: PaginationDto) {
    return await this.userService.findAll(query)
  }
}
```

1. 【推荐】复杂的业务逻辑添加必要的行内注释

```typescript
// 正确示例
async calculateOrderTotal(orderId: string): Promise<number> {
  const order = await this.prisma.order.findUnique({
    where: { id: orderId },
    include: {
      items: {
        include: { product: true }
      }
    }
  })
  
  if (!order) {
    throw new NotFoundException('订单不存在')
  }
  
  // 计算商品总价
  const subtotal = order.items.reduce((sum, item) => {
    return sum + item.product.price * item.quantity
  }, 0)
  
  // 应用优惠券折扣
  let discount = 0
  if (order.couponId) {
    const coupon = await this.prisma.coupon.findUnique({
      where: { id: order.couponId }
    })
    
    if (coupon && coupon.isValid) {
      // 根据优惠券类型计算折扣
      if (coupon.type === 'percentage') {
        discount = subtotal * (coupon.value / 100)
      } else if (coupon.type === 'fixed') {
        discount = Math.min(coupon.value, subtotal)
      }
    }
  }
  
  // 计算运费（满100免运费）
  const shippingFee = subtotal >= 100 ? 0 : 10
  
  // 最终金额 = 小计 - 折扣 + 运费
  return Math.max(0, subtotal - discount + shippingFee)
}
```

1. 【强制】TODO、FIXME、HACK 等标记必须包含说明和负责人

```typescript
// 正确示例
/**
 * TODO(zhangsan): 需要添加Redis缓存以提升查询性能 - 2025-10-20
 */
async getPopularPosts(): Promise<Post[]> {
  return await this.prisma.post.findMany({
    orderBy: { views: 'desc' },
    take: 10
  })
}

/**
 * FIXME(lisi): 此处可能存在并发问题，需要使用分布式锁 - 2025-10-18
 */
async updateInventory(productId: string, quantity: number): Promise<void> {
  const product = await this.prisma.product.findUnique({
    where: { id: productId }
  })
  
  await this.prisma.product.update({
    where: { id: productId },
    data: { stock: product.stock - quantity }
  })
}

/**
 * HACK(wangwu): 临时方案，等待第三方API修复后移除 - 2025-10-16
 */
const response = await this.httpService.get(url).catch(() => ({
  data: { fallback: true }
}))
```

## 2.8 异常处理

1. 【强制】使用统一的异常过滤器处理错误

```typescript
// 正确示例 - 全局异常过滤器
// filters/all-exceptions.filter.ts
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
  Logger
} from '@nestjs/common'
import { Request, Response } from 'express'
import { Prisma } from '@prisma/client'

@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  private readonly logger = new Logger(AllExceptionsFilter.name)
  
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp()
    const response = ctx.getResponse<Response>()
    const request = ctx.getRequest<Request>()
    
    let status = HttpStatus.INTERNAL_SERVER_ERROR
    let message = '服务器内部错误'
    let code = 'INTERNAL_SERVER_ERROR'
    
    // HTTP异常
    if (exception instanceof HttpException) {
      status = exception.getStatus()
      const exceptionResponse = exception.getResponse()
      
      if (typeof exceptionResponse === 'string') {
        message = exceptionResponse
      } else if (typeof exceptionResponse === 'object') {
        message = (exceptionResponse as any).message || message
        code = (exceptionResponse as any).code || code
      }
    }
    // Prisma异常
    else if (exception instanceof Prisma.PrismaClientKnownRequestError) {
      status = HttpStatus.BAD_REQUEST
      
      switch (exception.code) {
        case 'P2002':
          message = '数据已存在'
          code = 'DUPLICATE_ERROR'
          break
        case 'P2003':
          message = '关联数据不存在'
          code = 'FOREIGN_KEY_ERROR'
          break
        case 'P2025':
          message = '记录不存在'
          code = 'NOT_FOUND'
          break
        default:
          message = '数据库操作失败'
          code = 'DATABASE_ERROR'
      }
    }
    // 其他错误
    else if (exception instanceof Error) {
      message = exception.message
    }
    
    // 记录错误日志
    this.logger.error({
      timestamp: new Date().toISOString(),
      path: request.url,
      method: request.method,
      status,
      code,
      message,
      stack: exception instanceof Error ? exception.stack : undefined
    })
    
    // 返回统一格式的错误响应
    response.status(status).json({
      code: status,
      message,
      error: code,
      timestamp: new Date().toISOString(),
      path: request.url
    })
  }
}

// main.ts中注册
import { AllExceptionsFilter } from './filters/all-exceptions.filter'

async function bootstrap() {
  const app = await NestFactory.create(AppModule)
  app.useGlobalFilters(new AllExceptionsFilter())
  await app.listen(3000)
}
bootstrap()
```

1. 【推荐】定义业务异常类

```typescript
// 正确示例 - 自定义业务异常
// exceptions/business.exception.ts
import { HttpException, HttpStatus } from '@nestjs/common'

export class BusinessException extends HttpException {
  constructor(
    public readonly code: string,
    message: string,
    status: HttpStatus = HttpStatus.BAD_REQUEST
  ) {
    super(
      {
        code,
        message,
        error: 'BusinessError'
      },
      status
    )
  }
}

// 使用示例
import { BusinessException } from '@/exceptions/business.exception'
import { ERROR_CODES } from '@/constants/error-codes'

@Injectable()
export class UserService {
  async create(createUserDto: CreateUserDto): Promise<User> {
    const existingUser = await this.prisma.user.findUnique({
      where: { email: createUserDto.email }
    })
    
    if (existingUser) {
      throw new BusinessException(
        ERROR_CODES.EMAIL_ALREADY_EXISTS,
        '邮箱已被使用',
        HttpStatus.CONFLICT
      )
    }
    
    return await this.prisma.user.create({
      data: createUserDto
    })
  }
  
  async login(email: string, password: string): Promise<string> {
    const user = await this.prisma.user.findUnique({
      where: { email }
    })
    
    if (!user) {
      throw new BusinessException(
        ERROR_CODES.INVALID_CREDENTIALS,
        '邮箱或密码错误',
        HttpStatus.UNAUTHORIZED
      )
    }
    
    const isPasswordValid = await bcrypt.compare(password, user.passwordHash)
    
    if (!isPasswordValid) {
      throw new BusinessException(
        ERROR_CODES.INVALID_CREDENTIALS,
        '邮箱或密码错误',
        HttpStatus.UNAUTHORIZED
      )
    }
    
    return this.generateToken(user)
  }
}
```

1. 【强制】数据库操作异常进行分类处理

```typescript
// 正确示例
import { Prisma } from '@prisma/client'

@Injectable()
export class UserService {
  async create(createUserDto: CreateUserDto): Promise<User> {
    try {
      return await this.prisma.user.create({
        data: createUserDto
      })
    } catch (error) {
      // Prisma特定错误处理
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        // 唯一约束冲突
        if (error.code === 'P2002') {
          const field = (error.meta?.target as string[])?.[0]
          throw new BusinessException(
            ERROR_CODES.EMAIL_ALREADY_EXISTS,
            `${field}已存在`,
            HttpStatus.CONFLICT
          )
        }
        
        // 外键约束失败
        if (error.code === 'P2003') {
          throw new BusinessException(
            'FOREIGN_KEY_CONSTRAINT',
            '关联数据不存在',
            HttpStatus.BAD_REQUEST
          )
        }
        
        // 记录不存在
        if (error.code === 'P2025') {
          throw new NotFoundException('记录不存在')
        }
      }
      
      // 其他未知错误
      this.logger.error('创建用户失败:', error)
      throw new InternalServerErrorException('创建用户失败')
    }
  }
}
```

1. 【推荐】使用日志记录异常信息

```typescript
// 正确示例 - 日志记录
import { Logger } from '@nestjs/common'

@Injectable()
export class OrderService {
  private readonly logger = new Logger(OrderService.name)
  
  async processPayment(orderId: string): Promise<void> {
    this.logger.log(`开始处理订单支付: ${orderId}`)
    
    try {
      const order = await this.prisma.order.findUnique({
        where: { id: orderId }
      })
      
      if (!order) {
        this.logger.warn(`订单不存在: ${orderId}`)
        throw new NotFoundException('订单不存在')
      }
      
      // 调用支付接口
      const result = await this.paymentService.pay(order)
      
      this.logger.log(`订单支付成功: ${orderId}`, result)
    } catch (error) {
      this.logger.error(
        `订单支付失败: ${orderId}`,
        error.stack,
        OrderService.name
      )
      throw error
    }
  }
}
```

# 三、参考资料

- [Nest.js 官方文档](https://docs.nestjs.com/)
- [TypeScript 编码规范](https://google.github.io/styleguide/tsguide.html)
- [Prisma 最佳实践](https://www.prisma.io/docs/guides/performance-and-optimization)
- [Node.js 最佳实践](https://github.com/goldbergyoni/nodebestpractices)
- [Clean Code: A Handbook of Agile Software Craftsmanship](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)
- [阿里巴巴 Java 开发手册](https://github.com/alibaba/p3c)（部分通用规范可参考）

---
